#!/usr/bin/env python3
"""
Simple Python HTTP Server with Basic Authentication
Generated by SWARM: Local Code Agent (Qwen 32B)
Uses only standard library - no pip dependencies required.
"""

import base64
import http.server
import socketserver
import sys
from threading import Lock

# ==================== CONFIGURATION ====================
HOST = "0.0.0.0"      # Bind to all interfaces (use "127.0.0.1" for localhost only)
PORT = 8080           # Port to listen on
USERNAME = "admin"    # Basic auth username
PASSWORD = "secret"   # Basic auth password (change this!)
# =======================================================

# Thread-safe request counter
_request_counter = 0
_counter_lock = Lock()


class AuthHandler(http.server.SimpleHTTPRequestHandler):
    """HTTP request handler with Basic Authentication."""
    
    def require_auth(self):
        """Send 401 Unauthorized response."""
        self.send_response(401)
        self.send_header('WWW-Authenticate', 'Basic realm="Secure Area"')
        self.send_header('Content-type', 'text/html; charset=utf-8')
        self.end_headers()
        self.wfile.write(b"""<!DOCTYPE html>
<html>
<head><title>401 Unauthorized</title></head>
<body>
<h1>401 Unauthorized</h1>
<p>Valid credentials required.</p>
</body>
</html>""")
    
    def check_auth(self) -> bool:
        """Validate Basic Auth credentials from Authorization header."""
        auth_header = self.headers.get('Authorization', '')
        
        if not auth_header.startswith('Basic '):
            return False
        
        try:
            # Decode base64 credentials
            encoded_creds = auth_header[6:]  # Remove "Basic " prefix
            decoded_bytes = base64.b64decode(encoded_creds)
            decoded_creds = decoded_bytes.decode('utf-8')
            
            # Expected format: username:password
            parts = decoded_creds.split(':', 1)
            if len(parts) != 2:
                return False
            
            username, password = parts
            return username == USERNAME and password == PASSWORD
            
        except (ValueError, UnicodeDecodeError, base64.binascii.Error):
            return False
    
    def do_GET(self):
        """Handle GET requests with auth check."""
        if not self.check_auth():
            self.require_auth()
            return
        
        # Log authenticated request
        with _counter_lock:
            global _request_counter
            _request_counter += 1
            req_num = _request_counter
        
        print(f"[{req_num:04d}] Authenticated request: {self.path} from {self.client_address}")
        
        # Add custom headers
        self.send_response(200)
        self.send_header('Content-type', 'text/html; charset=utf-8')
        self.end_headers()
        
        # Generate dynamic response
        response = f"""<!DOCTYPE html>
<html>
<head>
    <title>Authenticated Server</title>
    <style>
        body {{ font-family: system-ui, sans-serif; max-width: 800px; margin: 50px auto; padding: 20px; }}
        .success {{ color: #28a745; }}
        code {{ background: #f4f4f4; padding: 2px 6px; border-radius: 3px; }}
        .info {{ background: #e9ecef; padding: 15px; border-radius: 5px; margin: 20px 0; }}
    </style>
</head>
<body>
    <h1 class="success">‚úì Authentication Successful</h1>
    <div class="info">
        <p><strong>Request #:</strong> {req_num}</p>
        <p><strong>Path:</strong> <code>{self.path}</code></p>
        <p><strong>Client:</strong> <code>{self.client_address[0]}</code></p>
    </div>
    <p>Your Python HTTP server with Basic Authentication is working!</p>
    <hr>
    <p><small>Powered by <code>http.server</code> with custom auth handler</small></p>
</body>
</html>"""
        
        self.wfile.write(response.encode('utf-8'))
    
    def do_POST(self):
        """Handle POST requests with auth check."""
        if not self.check_auth():
            self.require_auth()
            return
        
        # For testing, echo back the POST body
        content_length = int(self.headers.get('Content-Length', 0))
        post_data = self.rfile.read(content_length)
        
        self.send_response(200)
        self.send_header('Content-type', 'application/json')
        self.end_headers()
        
        response = f'{{"status": "ok", "path": "{self.path}", "received_bytes": {len(post_data)}}}'
        self.wfile.write(response.encode('utf-8'))
    
    def log_message(self, format, *args):
        """Override to suppress default logging (we handle it in do_GET)."""
        pass


class ThreadedHTTPServer(socketserver.ThreadingMixIn, http.server.HTTPServer):
    """Threaded HTTP server for concurrent connections."""
    daemon_threads = True
    allow_reuse_address = True


def main():
    """Start the authenticated HTTP server."""
    expected_creds = base64.b64encode(f"{USERNAME}:{PASSWORD}".encode()).decode()
    
    print("=" * 60)
    print("üîê Python HTTP Server with Basic Authentication")
    print("=" * 60)
    print(f"üìç Server:    http://{HOST}:{PORT}/")
    print(f"üë§ Username:  {USERNAME}")
    print(f"üîë Password:  {PASSWORD}")
    print(f"üß™ Test:      curl -u {USERNAME}:{PASSWORD} http://localhost:{PORT}/")
    print(f"   Or:        curl -H 'Authorization: Basic {expected_creds}' http://localhost:{PORT}/")
    print("=" * 60)
    print("Press Ctrl+C to stop")
    print("")
    
    server = ThreadedHTTPServer((HOST, PORT), AuthHandler)
    
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print("\nüõë Server stopping...")
        server.shutdown()
        sys.exit(0)


if __name__ == "__main__":
    main()
